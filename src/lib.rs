#![allow(non_camel_case_types)]

/* automatically generated by rust-bindgen 0.72.0 */

#[doc = " @typedef\n\n :type:`nghttp3_ssize` is signed counterpart of size_t."]
pub type nghttp3_ssize = isize;
#[doc = " @functypedef\n\n :type:`nghttp3_malloc` is a custom memory allocator to replace\n :manpage:`malloc(3)`.  The |user_data| is the\n :member:`nghttp3_mem.user_data`."]
pub type nghttp3_malloc = ::std::option::Option<
    unsafe extern "C" fn(
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_free` is a custom memory allocator to replace\n :manpage:`free(3)`.  The |user_data| is the\n :member:`nghttp3_mem.user_data`."]
pub type nghttp3_free = ::std::option::Option<
    unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void, user_data: *mut ::std::os::raw::c_void),
>;
#[doc = " @functypedef\n\n :type:`nghttp3_calloc` is a custom memory allocator to replace\n :manpage:`calloc(3)`.  The |user_data| is the\n :member:`nghttp3_mem.user_data`."]
pub type nghttp3_calloc = ::std::option::Option<
    unsafe extern "C" fn(
        nmemb: usize,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_realloc` is a custom memory allocator to replace\n :manpage:`realloc(3)`.  The |user_data| is the\n :member:`nghttp3_mem.user_data`."]
pub type nghttp3_realloc = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @struct\n\n :type:`nghttp3_mem` is a custom memory allocator functions and user\n defined pointer.  The :member:`user_data` field is passed to each\n allocator function.  This can be used, for example, to achieve\n per-session memory pool.\n\n In the following example code, ``my_malloc``, ``my_free``,\n ``my_calloc``, and ``my_realloc`` are the replacement of the\n standard allocators :manpage:`malloc(3)`, :manpage:`free(3)`,\n :manpage:`calloc(3)` and :manpage:`realloc(3)` respectively::\n\n     void *my_malloc_cb(size_t size, void *user_data) {\n       (void)user_data;\n       return my_malloc(size);\n     }\n\n     void my_free_cb(void *ptr, void *user_data) {\n       (void)user_data;\n       my_free(ptr);\n     }\n\n     void *my_calloc_cb(size_t nmemb, size_t size, void *user_data) {\n       (void)user_data;\n       return my_calloc(nmemb, size);\n     }\n\n     void *my_realloc_cb(void *ptr, size_t size, void *user_data) {\n       (void)user_data;\n       return my_realloc(ptr, size);\n     }\n\n     void conn_new() {\n       nghttp3_mem mem = {NULL, my_malloc_cb, my_free_cb, my_calloc_cb,\n                          my_realloc_cb};\n\n       ...\n     }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_mem {
    #[doc = " :member:`user_data` is an arbitrary user supplied data.  This is\n passed to each allocator function."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " :member:`malloc` is a custom allocator function to replace\n :manpage:`malloc(3)`."]
    pub malloc: nghttp3_malloc,
    #[doc = " :member:`free` is a custom allocator function to replace\n :manpage:`free(3)`."]
    pub free: nghttp3_free,
    #[doc = " :member:`calloc` is a custom allocator function to replace\n :manpage:`calloc(3)`."]
    pub calloc: nghttp3_calloc,
    #[doc = " :member:`realloc` is a custom allocator function to replace\n :manpage:`realloc(3)`."]
    pub realloc: nghttp3_realloc,
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_mem_default` returns the default memory allocator which\n uses malloc/calloc/realloc/free."]
    pub fn nghttp3_mem_default() -> *const nghttp3_mem;
}
#[doc = " @struct\n\n :type:`nghttp3_vec` is ``struct iovec`` compatible structure to\n reference arbitrary array of bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_vec {
    #[doc = " :member:`base` points to the data."]
    pub base: *mut u8,
    #[doc = " :member:`len` is the number of bytes which the buffer pointed by\n :member:`base` contains."]
    pub len: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_rcbuf {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_rcbuf_incref` increments the reference count of |rcbuf| by\n 1."]
    pub fn nghttp3_rcbuf_incref(rcbuf: *mut nghttp3_rcbuf);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_rcbuf_decref` decrements the reference count of |rcbuf| by\n 1.  If the reference count becomes zero, the object pointed by\n |rcbuf| will be freed.  In this case, application must not use\n |rcbuf| again."]
    pub fn nghttp3_rcbuf_decref(rcbuf: *mut nghttp3_rcbuf);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_rcbuf_get_buf` returns the underlying buffer managed by\n |rcbuf|."]
    pub fn nghttp3_rcbuf_get_buf(rcbuf: *const nghttp3_rcbuf) -> nghttp3_vec;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_rcbuf_is_static` returns nonzero if the underlying buffer\n is statically allocated, and 0 otherwise. This can be useful for\n language bindings that wish to avoid creating duplicate strings for\n these buffers."]
    pub fn nghttp3_rcbuf_is_static(rcbuf: *const nghttp3_rcbuf) -> ::std::os::raw::c_int;
}
#[doc = " @struct\n\n :type:`nghttp3_buf` is the variable size buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_buf {
    #[doc = " :member:`begin` points to the beginning of the buffer."]
    pub begin: *mut u8,
    #[doc = " :member:`end` points to the one beyond of the last byte of the\n buffer"]
    pub end: *mut u8,
    #[doc = " :member:`pos` points to the start of data.  Typically, this\n points to the address that next data should be read.  Initially,\n it points to :member:`begin`."]
    pub pos: *mut u8,
    #[doc = " :member:`last` points to the one beyond of the last data of the\n buffer.  Typically, new data is written at this point.\n Initially, it points to :member:`begin`."]
    pub last: *mut u8,
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_buf_init` initializes empty |buf|."]
    pub fn nghttp3_buf_init(buf: *mut nghttp3_buf);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_buf_free` frees resources allocated for |buf| using |mem|\n as memory allocator.  :member:`buf->begin <nghttp3_buf.begin>` must\n be a heap buffer allocated by |mem|."]
    pub fn nghttp3_buf_free(buf: *mut nghttp3_buf, mem: *const nghttp3_mem);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_buf_left` returns the number of additional bytes which can\n be written to the underlying buffer.  In other words, it returns\n :member:`buf->end <nghttp3_buf.end>` - :member:`buf->last\n <nghttp3_buf.last>`."]
    pub fn nghttp3_buf_left(buf: *const nghttp3_buf) -> usize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_buf_len` returns the number of bytes left to read.  In\n other words, it returns :member:`buf->last <nghttp3_buf.last>` -\n :member:`buf->pos <nghttp3_buf.pos>`."]
    pub fn nghttp3_buf_len(buf: *const nghttp3_buf) -> usize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_buf_reset` sets :member:`buf->pos <nghttp3_buf.pos>` and\n :member:`buf->last <nghttp3_buf.last>` to :member:`buf->begin\n <nghttp3_buf.begin>`."]
    pub fn nghttp3_buf_reset(buf: *mut nghttp3_buf);
}
#[doc = " @struct\n\n :type:`nghttp3_nv` is the name/value pair, which mainly used to\n represent HTTP fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_nv {
    #[doc = " :member:`name` is the HTTP field name."]
    pub name: *const u8,
    #[doc = " :member:`value` is the HTTP field value."]
    pub value: *const u8,
    #[doc = " :member:`namelen` is the length of the |name|, excluding\n terminating NULL."]
    pub namelen: usize,
    #[doc = " :member:`valuelen` is the length of the |value|, excluding\n terminating NULL."]
    pub valuelen: usize,
    #[doc = " :member:`flags` is bitwise OR of one or more of\n :macro:`NGHTTP3_NV_FLAG_* <NGHTTP3_NV_FLAG_NONE>`."]
    pub flags: u8,
}
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN__AUTHORITY` is a token for\n ``:authority``."]
pub const NGHTTP3_QPACK_TOKEN__AUTHORITY: nghttp3_qpack_token = 0;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN__PATH` is a token for ``:path``."]
pub const NGHTTP3_QPACK_TOKEN__PATH: nghttp3_qpack_token = 8;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_AGE` is a token for ``age``."]
pub const NGHTTP3_QPACK_TOKEN_AGE: nghttp3_qpack_token = 43;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_CONTENT_DISPOSITION` is a token for\n ``content-disposition``."]
pub const NGHTTP3_QPACK_TOKEN_CONTENT_DISPOSITION: nghttp3_qpack_token = 52;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_CONTENT_LENGTH` is a token for\n ``content-length``."]
pub const NGHTTP3_QPACK_TOKEN_CONTENT_LENGTH: nghttp3_qpack_token = 55;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_COOKIE` is a token for ``cookie``."]
pub const NGHTTP3_QPACK_TOKEN_COOKIE: nghttp3_qpack_token = 68;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_DATE` is a token for ``date``."]
pub const NGHTTP3_QPACK_TOKEN_DATE: nghttp3_qpack_token = 69;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ETAG` is a token for ``etag``."]
pub const NGHTTP3_QPACK_TOKEN_ETAG: nghttp3_qpack_token = 71;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_IF_MODIFIED_SINCE` is a token for\n ``if-modified-since``."]
pub const NGHTTP3_QPACK_TOKEN_IF_MODIFIED_SINCE: nghttp3_qpack_token = 74;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_IF_NONE_MATCH` is a token for\n ``if-none-match``."]
pub const NGHTTP3_QPACK_TOKEN_IF_NONE_MATCH: nghttp3_qpack_token = 75;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_LAST_MODIFIED` is a token for\n ``last-modified``."]
pub const NGHTTP3_QPACK_TOKEN_LAST_MODIFIED: nghttp3_qpack_token = 77;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_LINK` is a token for ``link``."]
pub const NGHTTP3_QPACK_TOKEN_LINK: nghttp3_qpack_token = 78;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_LOCATION` is a token for ``location``."]
pub const NGHTTP3_QPACK_TOKEN_LOCATION: nghttp3_qpack_token = 79;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_REFERER` is a token for ``referer``."]
pub const NGHTTP3_QPACK_TOKEN_REFERER: nghttp3_qpack_token = 83;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_SET_COOKIE` is a token for\n ``set-cookie``."]
pub const NGHTTP3_QPACK_TOKEN_SET_COOKIE: nghttp3_qpack_token = 85;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN__METHOD` is a token for ``:method``."]
pub const NGHTTP3_QPACK_TOKEN__METHOD: nghttp3_qpack_token = 1;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN__SCHEME` is a token for ``:scheme``."]
pub const NGHTTP3_QPACK_TOKEN__SCHEME: nghttp3_qpack_token = 9;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN__STATUS` is a token for ``:status``."]
pub const NGHTTP3_QPACK_TOKEN__STATUS: nghttp3_qpack_token = 11;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCEPT` is a token for ``accept``."]
pub const NGHTTP3_QPACK_TOKEN_ACCEPT: nghttp3_qpack_token = 25;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCEPT_ENCODING` is a token for\n ``accept-encoding``."]
pub const NGHTTP3_QPACK_TOKEN_ACCEPT_ENCODING: nghttp3_qpack_token = 27;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCEPT_RANGES` is a token for\n ``accept-ranges``."]
pub const NGHTTP3_QPACK_TOKEN_ACCEPT_RANGES: nghttp3_qpack_token = 29;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS` is a\n token for ``access-control-allow-headers``."]
pub const NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS: nghttp3_qpack_token = 32;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_ORIGIN` is a\n token for ``access-control-allow-origin``."]
pub const NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_ORIGIN: nghttp3_qpack_token = 38;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_CACHE_CONTROL` is a token for\n ``cache-control``."]
pub const NGHTTP3_QPACK_TOKEN_CACHE_CONTROL: nghttp3_qpack_token = 46;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_CONTENT_ENCODING` is a token for\n ``content-encoding``."]
pub const NGHTTP3_QPACK_TOKEN_CONTENT_ENCODING: nghttp3_qpack_token = 53;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_CONTENT_TYPE` is a token for\n ``content-type``."]
pub const NGHTTP3_QPACK_TOKEN_CONTENT_TYPE: nghttp3_qpack_token = 57;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_RANGE` is a token for ``range``."]
pub const NGHTTP3_QPACK_TOKEN_RANGE: nghttp3_qpack_token = 82;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY` is a token\n for ``strict-transport-security``."]
pub const NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY: nghttp3_qpack_token = 86;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_VARY` is a token for ``vary``."]
pub const NGHTTP3_QPACK_TOKEN_VARY: nghttp3_qpack_token = 92;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_X_CONTENT_TYPE_OPTIONS` is a token for\n ``x-content-type-options``."]
pub const NGHTTP3_QPACK_TOKEN_X_CONTENT_TYPE_OPTIONS: nghttp3_qpack_token = 94;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_X_XSS_PROTECTION` is a token for\n ``x-xss-protection``."]
pub const NGHTTP3_QPACK_TOKEN_X_XSS_PROTECTION: nghttp3_qpack_token = 98;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCEPT_LANGUAGE` is a token for\n ``accept-language``."]
pub const NGHTTP3_QPACK_TOKEN_ACCEPT_LANGUAGE: nghttp3_qpack_token = 28;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_CREDENTIALS` is a\n token for ``access-control-allow-credentials``."]
pub const NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_CREDENTIALS: nghttp3_qpack_token = 30;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS` is a\n token for ``access-control-allow-methods``."]
pub const NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS: nghttp3_qpack_token = 35;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_EXPOSE_HEADERS` is a\n token for ``access-control-expose-headers``."]
pub const NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_EXPOSE_HEADERS: nghttp3_qpack_token = 39;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_HEADERS` is a\n token for ``access-control-request-headers``."]
pub const NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_HEADERS: nghttp3_qpack_token = 40;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_METHOD` is a\n token for ``access-control-request-method``."]
pub const NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_METHOD: nghttp3_qpack_token = 41;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ALT_SVC` is a token for ``alt-svc``."]
pub const NGHTTP3_QPACK_TOKEN_ALT_SVC: nghttp3_qpack_token = 44;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_AUTHORIZATION` is a token for\n ``authorization``."]
pub const NGHTTP3_QPACK_TOKEN_AUTHORIZATION: nghttp3_qpack_token = 45;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_CONTENT_SECURITY_POLICY` is a token\n for ``content-security-policy``."]
pub const NGHTTP3_QPACK_TOKEN_CONTENT_SECURITY_POLICY: nghttp3_qpack_token = 56;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_EARLY_DATA` is a token for\n ``early-data``."]
pub const NGHTTP3_QPACK_TOKEN_EARLY_DATA: nghttp3_qpack_token = 70;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_EXPECT_CT` is a token for\n ``expect-ct``."]
pub const NGHTTP3_QPACK_TOKEN_EXPECT_CT: nghttp3_qpack_token = 72;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_FORWARDED` is a token for\n ``forwarded``."]
pub const NGHTTP3_QPACK_TOKEN_FORWARDED: nghttp3_qpack_token = 73;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_IF_RANGE` is a token for ``if-range``."]
pub const NGHTTP3_QPACK_TOKEN_IF_RANGE: nghttp3_qpack_token = 76;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_ORIGIN` is a token for ``origin``."]
pub const NGHTTP3_QPACK_TOKEN_ORIGIN: nghttp3_qpack_token = 80;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_PURPOSE` is a token for ``purpose``."]
pub const NGHTTP3_QPACK_TOKEN_PURPOSE: nghttp3_qpack_token = 81;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_SERVER` is a token for ``server``."]
pub const NGHTTP3_QPACK_TOKEN_SERVER: nghttp3_qpack_token = 84;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_TIMING_ALLOW_ORIGIN` is a token for\n ``timing-allow-origin``."]
pub const NGHTTP3_QPACK_TOKEN_TIMING_ALLOW_ORIGIN: nghttp3_qpack_token = 89;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_UPGRADE_INSECURE_REQUESTS` is a token\n for ``upgrade-insecure-requests``."]
pub const NGHTTP3_QPACK_TOKEN_UPGRADE_INSECURE_REQUESTS: nghttp3_qpack_token = 90;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_USER_AGENT` is a token for\n ``user-agent``."]
pub const NGHTTP3_QPACK_TOKEN_USER_AGENT: nghttp3_qpack_token = 91;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_X_FORWARDED_FOR` is a token for\n ``x-forwarded-for``."]
pub const NGHTTP3_QPACK_TOKEN_X_FORWARDED_FOR: nghttp3_qpack_token = 95;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_X_FRAME_OPTIONS` is a token for\n ``x-frame-options``."]
pub const NGHTTP3_QPACK_TOKEN_X_FRAME_OPTIONS: nghttp3_qpack_token = 96;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_HOST` is a token for ``host``."]
pub const NGHTTP3_QPACK_TOKEN_HOST: nghttp3_qpack_token = 1000;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_CONNECTION` is a token for\n ``connection``."]
pub const NGHTTP3_QPACK_TOKEN_CONNECTION: nghttp3_qpack_token = 1001;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_KEEP_ALIVE` is a token for\n ``keep-alive``."]
pub const NGHTTP3_QPACK_TOKEN_KEEP_ALIVE: nghttp3_qpack_token = 1002;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_PROXY_CONNECTION` is a token for\n ``proxy-connection``."]
pub const NGHTTP3_QPACK_TOKEN_PROXY_CONNECTION: nghttp3_qpack_token = 1003;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_TRANSFER_ENCODING` is a token for\n ``transfer-encoding``."]
pub const NGHTTP3_QPACK_TOKEN_TRANSFER_ENCODING: nghttp3_qpack_token = 1004;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_UPGRADE` is a token for ``upgrade``."]
pub const NGHTTP3_QPACK_TOKEN_UPGRADE: nghttp3_qpack_token = 1005;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_TE` is a token for ``te``."]
pub const NGHTTP3_QPACK_TOKEN_TE: nghttp3_qpack_token = 1006;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN__PROTOCOL` is a token for\n ``:protocol``."]
pub const NGHTTP3_QPACK_TOKEN__PROTOCOL: nghttp3_qpack_token = 1007;
#[doc = " :enum:`NGHTTP3_QPACK_TOKEN_PRIORITY` is a token for ``priority``."]
pub const NGHTTP3_QPACK_TOKEN_PRIORITY: nghttp3_qpack_token = 1008;
#[doc = " @enum\n\n :type:`nghttp3_qpack_token` defines HTTP field name tokens to\n identify field name quickly.  It appears in\n :member:`nghttp3_qpack_nv.token`."]
pub type nghttp3_qpack_token = ::std::os::raw::c_uint;
#[doc = " @struct\n\n :type:`nghttp3_qpack_nv` represents HTTP field name/value pair just\n like :type:`nghttp3_nv`.  It is an extended version of\n :type:`nghttp3_nv`, and has reference counted buffers and tokens."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_qpack_nv {
    #[doc = " :member:`name` is the buffer containing HTTP field name.\n NULL-termination is guaranteed."]
    pub name: *mut nghttp3_rcbuf,
    #[doc = " :member:`value` is the buffer containing HTTP field value.\n NULL-termination is guaranteed."]
    pub value: *mut nghttp3_rcbuf,
    #[doc = " :member:`token` is :type:`nghttp3_qpack_token` value of\n :member:`name`.  It could be -1 if we have no token for that HTTP\n field name."]
    pub token: i32,
    #[doc = " :member:`flags` is a bitwise OR of one or more of\n :macro:`NGHTTP3_NV_FLAG_* <NGHTTP3_NV_FLAG_NONE>`."]
    pub flags: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_qpack_encoder {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_encoder_new` initializes QPACK encoder.  |pencoder|\n must be non-NULL pointer.  |hard_max_dtable_capacity| is the upper\n bound of the dynamic table capacity.  |mem| is a memory allocator.\n This function allocates memory for :type:`nghttp3_qpack_encoder`\n itself, and assigns its pointer to |*pencoder| if it succeeds.\n\n The maximum dynamic table capacity is still 0.  In order to change\n the maximum dynamic table capacity, call\n `nghttp3_qpack_encoder_set_max_dtable_capacity`.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory.\n\n See also `nghttp3_qpack_encoder_new2`.  This function calls\n `nghttp3_qpack_encoder_new2` with the given parameters and 0 as\n seed."]
    pub fn nghttp3_qpack_encoder_new(
        pencoder: *mut *mut nghttp3_qpack_encoder,
        hard_max_dtable_capacity: usize,
        mem: *const nghttp3_mem,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_encoder_new2` initializes QPACK encoder.  |pencoder|\n must be non-NULL pointer.  |hard_max_dtable_capacity| is the upper\n bound of the dynamic table capacity.  |seed| must be unpredictable\n value, and is used to seed the internal data structure.  |mem| is a\n memory allocator.  This function allocates memory for\n :type:`nghttp3_qpack_encoder` itself, and assigns its pointer to\n |*pencoder| if it succeeds.\n\n The maximum dynamic table capacity is still 0.  In order to change\n the maximum dynamic table capacity, call\n `nghttp3_qpack_encoder_set_max_dtable_capacity`.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory.\n\n This function is available since v1.11.0."]
    pub fn nghttp3_qpack_encoder_new2(
        pencoder: *mut *mut nghttp3_qpack_encoder,
        hard_max_dtable_capacity: usize,
        seed: u64,
        mem: *const nghttp3_mem,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_encoder_del` frees memory allocated for |encoder|.\n This function also frees memory pointed by |encoder| itself.  This\n function does nothing if |encoder| is NULL."]
    pub fn nghttp3_qpack_encoder_del(encoder: *mut nghttp3_qpack_encoder);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_encoder_encode` encodes the list of HTTP fields\n |nva|.  |nvlen| is the length of |nva|.  |stream_id| is the\n identifier of the stream which these HTTP fields belong to.  This\n function writes field section prefix, encoded HTTP field section,\n and encoder stream to |pbuf|, |rbuf|, and |ebuf| respectively.\n Each :member:`nghttp3_buf.last` will be adjusted when data is\n written.  An application should write |pbuf| and |rbuf| to the\n request stream in this order.\n\n The buffer pointed by |pbuf|, |rbuf|, and |ebuf| can be empty\n buffer.  It is fine to pass a buffer initialized by\n `nghttp3_buf_init(buf) <nghttp3_buf_init>`.  This function\n allocates memory for these buffers as necessary.  In particular, it\n frees and expands buffer if the current capacity of buffer is not\n enough.  If :member:`nghttp3_buf.begin` of any buffer is not NULL,\n it must be allocated by the same memory allocator passed to\n `nghttp3_qpack_encoder_new`.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory\n :macro:`NGHTTP3_ERR_QPACK_FATAL`\n      |encoder| is in unrecoverable error state, and cannot be used\n      anymore."]
    pub fn nghttp3_qpack_encoder_encode(
        encoder: *mut nghttp3_qpack_encoder,
        pbuf: *mut nghttp3_buf,
        rbuf: *mut nghttp3_buf,
        ebuf: *mut nghttp3_buf,
        stream_id: i64,
        nva: *const nghttp3_nv,
        nvlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_encoder_read_decoder` reads decoder stream.  The\n buffer pointed by |src| of length |srclen| contains decoder stream.\n\n This function returns the number of bytes read, or one of the\n following negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory\n :macro:`NGHTTP3_ERR_QPACK_FATAL`\n     |encoder| is in unrecoverable error state, and cannot be used\n     anymore.\n :macro:`NGHTTP3_ERR_QPACK_DECODER_STREAM`\n     |encoder| is unable to process input because it is malformed."]
    pub fn nghttp3_qpack_encoder_read_decoder(
        encoder: *mut nghttp3_qpack_encoder,
        src: *const u8,
        srclen: usize,
    ) -> nghttp3_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_encoder_set_max_dtable_capacity` sets max dynamic\n table capacity to |max_dtable_capacity|.  If |max_dtable_capacity|\n is larger than ``hard_max_dtable_capacity`` parameter of\n `nghttp3_qpack_encoder_new`, it is truncated to the latter."]
    pub fn nghttp3_qpack_encoder_set_max_dtable_capacity(
        encoder: *mut nghttp3_qpack_encoder,
        max_dtable_capacity: usize,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_encoder_set_max_blocked_streams` sets the number of\n streams which can be blocked to |max_blocked_streams|."]
    pub fn nghttp3_qpack_encoder_set_max_blocked_streams(
        encoder: *mut nghttp3_qpack_encoder,
        max_blocked_streams: usize,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_encoder_ack_everything` tells |encoder| that all\n encoded HTTP field sections are acknowledged.  This function is\n provided for debugging purpose only.  In HTTP/3, |encoder| knows\n this by reading decoder stream with\n `nghttp3_qpack_encoder_read_decoder`."]
    pub fn nghttp3_qpack_encoder_ack_everything(encoder: *mut nghttp3_qpack_encoder);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_encoder_get_num_blocked_streams` returns the number\n of streams which are potentially blocked at decoder side."]
    pub fn nghttp3_qpack_encoder_get_num_blocked_streams(
        encoder: *mut nghttp3_qpack_encoder,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_qpack_stream_context {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_stream_context_new` initializes stream context.\n |psctx| must be non-NULL pointer.  |stream_id| is stream ID.  |mem|\n is a memory allocator.  This function allocates memory for\n :type:`nghttp3_qpack_stream_context` itself, and assigns its\n pointer to |*psctx| if it succeeds.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_qpack_stream_context_new(
        psctx: *mut *mut nghttp3_qpack_stream_context,
        stream_id: i64,
        mem: *const nghttp3_mem,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_stream_context_del` frees memory allocated for\n |sctx|.  This function frees memory pointed by |sctx| itself.  This\n function does nothing if |sctx| is NULL."]
    pub fn nghttp3_qpack_stream_context_del(sctx: *mut nghttp3_qpack_stream_context);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_stream_context_get_ricnt` returns required insert\n count."]
    pub fn nghttp3_qpack_stream_context_get_ricnt(sctx: *mut nghttp3_qpack_stream_context) -> u64;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_stream_context_reset` resets the state of |sctx|.\n Then it can be reused for decoding an another HTTP field section in\n the same stream."]
    pub fn nghttp3_qpack_stream_context_reset(sctx: *mut nghttp3_qpack_stream_context);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_qpack_decoder {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_new` initializes QPACK decoder.  |pdecoder|\n must be non-NULL pointer.  |hard_max_dtable_capacity| is the upper\n bound of the dynamic table capacity.  |max_blocked_streams| is the\n maximum number of streams which can be blocked.  |mem| is a memory\n allocator.  This function allocates memory for\n :type:`nghttp3_qpack_decoder` itself, and assigns its pointer to\n |*pdecoder| if it succeeds.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_qpack_decoder_new(
        pdecoder: *mut *mut nghttp3_qpack_decoder,
        hard_max_dtable_capacity: usize,
        max_blocked_streams: usize,
        mem: *const nghttp3_mem,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_del` frees memory allocated for |decoder|.\n This function frees memory pointed by |decoder| itself.  This\n function does nothing if |decoder| is NULL."]
    pub fn nghttp3_qpack_decoder_del(decoder: *mut nghttp3_qpack_decoder);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_read_encoder` reads encoder stream.  The\n buffer pointed by |src| of length |srclen| contains encoder stream.\n\n This function returns the number of bytes read, or one of the\n following negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory.\n :macro:`NGHTTP3_ERR_QPACK_FATAL`\n     |decoder| is in unrecoverable error state, and cannot be used\n     anymore.\n :macro:`NGHTTP3_ERR_QPACK_ENCODER_STREAM`\n     Could not interpret encoder stream instruction."]
    pub fn nghttp3_qpack_decoder_read_encoder(
        decoder: *mut nghttp3_qpack_decoder,
        src: *const u8,
        srclen: usize,
    ) -> nghttp3_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_get_icnt` returns insert count."]
    pub fn nghttp3_qpack_decoder_get_icnt(decoder: *const nghttp3_qpack_decoder) -> u64;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_read_request` reads request stream.  The\n request stream is given as the buffer pointed by |src| of length\n |srclen|.  |sctx| is the stream context, and it must be created by\n `nghttp3_qpack_stream_context_new`.  |*pflags| must be non-NULL\n pointer.  |nv| must be non-NULL pointer.\n\n If this function succeeds, it assigns flags to |*pflags|.  If\n |*pflags| has :macro:`NGHTTP3_QPACK_DECODE_FLAG_EMIT` set, a\n decoded HTTP field is assigned to |nv|.  If |*pflags| has\n :macro:`NGHTTP3_QPACK_DECODE_FLAG_FINAL` set, an entire HTTP field\n section has been successfully decoded.  If |*pflags| has\n :macro:`NGHTTP3_QPACK_DECODE_FLAG_BLOCKED` set, decoding is blocked\n due to required insert count.\n\n When an HTTP field is decoded, an application receives it in |nv|.\n :member:`nv->name <nghttp3_qpack_nv.name>` and :member:`nv->value\n <nghttp3_qpack_nv.value>` are reference counted buffer, and their\n reference counts are already incremented for application use.\n Therefore, when application finishes processing |nv|, it must call\n `nghttp3_rcbuf_decref(nv->name) <nghttp3_rcbuf_decref>` and\n `nghttp3_rcbuf_decref(nv->value) <nghttp3_rcbuf_decref>`, or memory\n leak might occur.  These :type:`nghttp3_rcbuf` objects hold the\n pointer to :type:`nghttp3_mem` that is passed to\n `nghttp3_qpack_decoder_new` (or either `nghttp3_conn_client_new` or\n `nghttp3_conn_server_new` if it is used indirectly).  As long as\n these objects are alive, the pointed :type:`nghttp3_mem` object\n must be available.  Otherwise, `nghttp3_rcbuf_decref` will cause\n undefined behavior.\n\n This function returns the number of bytes read, or one of the\n following negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory.\n :macro:`NGHTTP3_ERR_QPACK_FATAL`\n     |decoder| is in unrecoverable error state, and cannot be used\n     anymore.\n :macro:`NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED`\n     Could not interpret field line representations.\n :macro:`NGHTTP3_ERR_QPACK_HEADER_TOO_LARGE`\n     HTTP field is too large."]
    pub fn nghttp3_qpack_decoder_read_request(
        decoder: *mut nghttp3_qpack_decoder,
        sctx: *mut nghttp3_qpack_stream_context,
        nv: *mut nghttp3_qpack_nv,
        pflags: *mut u8,
        src: *const u8,
        srclen: usize,
        fin: ::std::os::raw::c_int,
    ) -> nghttp3_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_write_decoder` writes decoder stream into\n |dbuf|.\n\n The caller must ensure that `nghttp3_buf_left(dbuf)\n <nghttp3_buf_left>` >=\n `nghttp3_qpack_decoder_get_decoder_streamlen(decoder)\n <nghttp3_qpack_decoder_get_decoder_streamlen>`."]
    pub fn nghttp3_qpack_decoder_write_decoder(
        decoder: *mut nghttp3_qpack_decoder,
        dbuf: *mut nghttp3_buf,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_get_decoder_streamlen` returns the length of\n decoder stream that is currently pending."]
    pub fn nghttp3_qpack_decoder_get_decoder_streamlen(
        decoder: *mut nghttp3_qpack_decoder,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_cancel_stream` cancels HTTP field section\n decoding for stream denoted by |stream_id|.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory.\n :macro:`NGHTTP3_ERR_QPACK_FATAL`\n     Decoder stream overflow."]
    pub fn nghttp3_qpack_decoder_cancel_stream(
        decoder: *mut nghttp3_qpack_decoder,
        stream_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_set_max_dtable_capacity` sets\n |max_dtable_capacity| as maximum dynamic table size.\n |max_dtable_capacity| must be equal to, or smaller than\n ``hard_max_dtable_capacity`` parameter of\n `nghttp3_qpack_decoder_new`.  Normally, the maximum capacity is\n communicated in encoder stream.  This function is provided for\n debugging and testing purpose.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_INVALID_ARGUMENT`\n     |max_dtable_capacity| exceeds the upper bound of the dynamic\n     table capacity."]
    pub fn nghttp3_qpack_decoder_set_max_dtable_capacity(
        decoder: *mut nghttp3_qpack_decoder,
        max_dtable_capacity: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_qpack_decoder_set_max_concurrent_streams` tells |decoder|\n the maximum number of concurrent streams that a remote endpoint can\n open, including both bidirectional and unidirectional streams which\n potentially receive QPACK encoded HEADERS frame.  This value is\n used as a hint to limit the length of decoder stream."]
    pub fn nghttp3_qpack_decoder_set_max_concurrent_streams(
        decoder: *mut nghttp3_qpack_decoder,
        max_concurrent_streams: usize,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_strerror` returns textual representation of |liberr|."]
    pub fn nghttp3_strerror(liberr: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_err_infer_quic_app_error_code` returns a QUIC application\n error code which corresponds to |liberr|."]
    pub fn nghttp3_err_infer_quic_app_error_code(liberr: ::std::os::raw::c_int) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_conn {
    _unused: [u8; 0],
}
#[doc = " @struct\n\n :type:`nghttp3_settings` defines HTTP/3 settings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_settings {
    #[doc = " :member:`max_field_section_size` specifies the maximum header\n section (block) size."]
    pub max_field_section_size: u64,
    #[doc = " :member:`qpack_max_dtable_capacity` is the maximum size of QPACK\n dynamic table."]
    pub qpack_max_dtable_capacity: usize,
    #[doc = " :member:`qpack_encoder_max_dtable_capacity` is the upper bound of\n QPACK dynamic table capacity that the QPACK encoder is willing to\n use.  The effective maximum dynamic table capacity is the minimum\n of this field and the value of the received\n SETTINGS_QPACK_MAX_TABLE_CAPACITY.  If this field is set to 0,\n the encoder does not use the dynamic table.\n\n When :type:`nghttp3_settings` is passed to\n :member:`nghttp3_callbacks.recv_settings` callback, this field\n should be ignored."]
    pub qpack_encoder_max_dtable_capacity: usize,
    #[doc = " :member:`qpack_blocked_streams` is the maximum number of streams\n which can be blocked while they are being decoded."]
    pub qpack_blocked_streams: usize,
    #[doc = " :member:`enable_connect_protocol`, if set to nonzero, enables\n Extended CONNECT Method (see :rfc:`9220`).  Client ignores this\n field."]
    pub enable_connect_protocol: u8,
    #[doc = " :member:`h3_datagram`, if set to nonzero, enables HTTP/3\n Datagrams (see :rfc:`9297`)."]
    pub h3_datagram: u8,
    #[doc = " :member:`origin_list`, if set, must contain a serialized HTTP/3\n ORIGIN frame (see :rfc:`9412`) payload.  The ORIGIN frame payload\n is a sequence of zero or more of a length prefixed byte string.\n The length is encoded in 2 bytes in network byte order.  If\n :member:`origin_list->len <nghttp3_vec.len>` is zero, an empty\n ORIGIN frame is sent.  An application must keep the buffer\n pointed by :member:`origin_list->base <nghttp3_vec.base>` alive\n until the :type:`nghttp3_conn` to which this field was passed is\n freed by `nghttp3_conn_del`.  The object pointed to by this field\n is copied internally, and does not need to be kept alive.  Only\n server uses this field.  This field is available since v1.11.0."]
    pub origin_list: *const nghttp3_vec,
}
#[doc = " @functypedef\n\n :type:`nghttp3_acked_stream_data` is a callback function which is\n invoked when data sent on stream denoted by |stream_id| supplied\n from application is acknowledged by remote endpoint.  The number of\n bytes acknowledged is given in |datalen|.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_acked_stream_data = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        datalen: u64,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_conn_stream_close` is a callback function which is\n invoked when a stream identified by |stream_id| is closed.  QUIC\n application error code |app_error_code| indicates the reason of\n this closure.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_stream_close = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        app_error_code: u64,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_recv_data` is a callback function which is invoked\n when a part of request or response body on stream identified by\n |stream_id| is received.  |data| points to the received data, and\n its length is |datalen|.\n\n The application is responsible for increasing flow control credit\n (say, increasing by |datalen| bytes).\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_recv_data = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        data: *const u8,
        datalen: usize,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_deferred_consume` is a callback function which is\n invoked when the library consumed |consumed| bytes for a stream\n identified by |stream_id|.  This callback is used to notify the\n consumed bytes for stream blocked due to synchronization between\n streams.  The application is responsible for increasing flow\n control credit by |consumed| bytes.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_deferred_consume = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        consumed: usize,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_begin_headers` is a callback function which is\n invoked when an incoming HTTP field section is started on a stream\n denoted by |stream_id|.  Each HTTP field is passed to application\n by :type:`nghttp3_recv_header` callback.  And then\n :type:`nghttp3_end_headers` is called when a whole HTTP field\n section is processed.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_begin_headers = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_recv_header` is a callback function which is invoked\n when an HTTP field is received on a stream denoted by |stream_id|.\n |name| contains a field name, and |value| contains a field value.\n |token| is one of token defined in :type:`nghttp3_qpack_token` or\n -1 if no token is defined for |name|.  |flags| is bitwise OR of\n zero or more of :macro:`NGHTTP3_NV_FLAG_* <NGHTTP3_NV_FLAG_NONE>`.\n\n The buffers for |name| and |value| are reference counted. If\n application needs to keep them, increment the reference count with\n `nghttp3_rcbuf_incref`.  When they are no longer used, call\n `nghttp3_rcbuf_decref`.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_recv_header = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        token: i32,
        name: *mut nghttp3_rcbuf,
        value: *mut nghttp3_rcbuf,
        flags: u8,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_end_headers` is a callback function which is invoked\n when an incoming HTTP field section has ended.\n\n If the stream ends with this HTTP field section, |fin| is set to\n nonzero.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_end_headers = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        fin: ::std::os::raw::c_int,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_end_stream` is a callback function which is invoked\n when the receiving side of stream is closed.  For server, this\n callback function is invoked when HTTP request is received\n completely.  For client, this callback function is invoked when\n HTTP response is received completely.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_end_stream = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_stop_sending` is a callback function which is\n invoked when the library asks application to send STOP_SENDING to\n the stream identified by |stream_id|.  QUIC application error code\n |app_error_code| indicates the reason for this action.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_stop_sending = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        app_error_code: u64,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_reset_stream` is a callback function which is\n invoked when the library asks application to reset stream\n identified by |stream_id|.  QUIC application error code\n |app_error_code| indicates the reason for this action.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_reset_stream = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        app_error_code: u64,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_shutdown` is a callback function which is invoked\n when a shutdown is initiated by the remote endpoint. For client,\n |id| contains a stream ID of a client initiated stream, for server,\n it contains a push ID. All client streams with stream ID, or pushes\n with push ID equal to, or larger than |ID| are guaranteed to not be\n processed by the remote endpoint.  Note that libnghttp3 does not\n implement Server Push.\n\n Parameter |id| for client can contain a special value\n :macro:`NGHTTP3_SHUTDOWN_NOTICE_STREAM_ID`, and for server it can\n contain special value\n :macro:`NGHTTP3_SHUTDOWN_NOTICE_PUSH_ID`. These values signal\n request for graceful shutdown of the connection, triggered by\n remote endpoint's invocation of\n `nghttp3_conn_submit_shutdown_notice`.\n\n It is possible that this callback is invoked multiple times on a\n single connection, however the |id| can only stay the same or\n decrease, never increase.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_shutdown = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        id: i64,
        conn_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_recv_settings` is a callback function which is\n invoked when SETTINGS frame is received.  |settings| is a received\n remote HTTP/3 settings.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_recv_settings = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        settings: *const nghttp3_settings,
        conn_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_recv_origin` is a callback function which is invoked\n when a single origin in ORIGIN frame is received.  |origin| is a\n received origin of length |originlen|.  |originlen| never be 0.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_recv_origin = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        origin: *const u8,
        originlen: usize,
        conn_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_end_origin` is a callback function which is invoked\n when an ORIGIN frame has been completely processed.\n\n The implementation of this callback must return 0 if it succeeds.\n Returning :macro:`NGHTTP3_ERR_CALLBACK_FAILURE` will return to the\n caller immediately.  Any values other than 0 is treated as\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`."]
pub type nghttp3_end_origin = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        conn_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @functypedef\n\n :type:`nghttp3_rand` is a callback function which is invoked when\n unpredictable data of |destlen| bytes are needed.  The\n implementation must write unpredictable data of |destlen| bytes\n into the buffer pointed by |dest|."]
pub type nghttp3_rand = ::std::option::Option<unsafe extern "C" fn(dest: *mut u8, destlen: usize)>;
#[doc = " @struct\n\n :type:`nghttp3_callbacks` holds a set of callback functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_callbacks {
    #[doc = " :member:`acked_stream_data` is a callback function which is\n invoked when data sent on a particular stream have been\n acknowledged by a remote endpoint."]
    pub acked_stream_data: nghttp3_acked_stream_data,
    #[doc = " :member:`stream_close` is a callback function which is invoked\n when a particular stream has closed."]
    pub stream_close: nghttp3_stream_close,
    #[doc = " :member:`recv_data` is a callback function which is invoked when\n stream data is received."]
    pub recv_data: nghttp3_recv_data,
    #[doc = " :member:`deferred_consume` is a callback function which is\n invoked when the library consumed data for a particular stream\n which had been blocked for synchronization between streams."]
    pub deferred_consume: nghttp3_deferred_consume,
    #[doc = " :member:`begin_headers` is a callback function which is invoked\n when an HTTP header field section has started on a particular\n stream."]
    pub begin_headers: nghttp3_begin_headers,
    #[doc = " :member:`recv_header` is a callback function which is invoked\n when a single HTTP header field is received on a particular\n stream."]
    pub recv_header: nghttp3_recv_header,
    #[doc = " :member:`end_headers` is a callback function which is invoked\n when an HTTP header field section has ended on a particular\n stream."]
    pub end_headers: nghttp3_end_headers,
    #[doc = " :member:`begin_trailers` is a callback function which is invoked\n when an HTTP trailer field section has started on a particular\n stream."]
    pub begin_trailers: nghttp3_begin_headers,
    #[doc = " :member:`recv_trailer` is a callback function which is invoked\n when a single HTTP trailer field is received on a particular\n stream."]
    pub recv_trailer: nghttp3_recv_header,
    #[doc = " :member:`end_trailers` is a callback function which is invoked\n when an HTTP trailer field section has ended on a particular\n stream."]
    pub end_trailers: nghttp3_end_headers,
    #[doc = " :member:`stop_sending` is a callback function which is invoked\n when the library asks application to send STOP_SENDING to a\n particular stream."]
    pub stop_sending: nghttp3_stop_sending,
    #[doc = " :member:`end_stream` is a callback function which is invoked when\n a receiving side of stream has been closed."]
    pub end_stream: nghttp3_end_stream,
    #[doc = " :member:`reset_stream` is a callback function which is invoked\n when the library asks application to reset stream (by sending\n RESET_STREAM)."]
    pub reset_stream: nghttp3_reset_stream,
    #[doc = " :member:`shutdown` is a callback function which is invoked when\n the remote endpoint has signalled initiation of connection\n shutdown."]
    pub shutdown: nghttp3_shutdown,
    #[doc = " :member:`recv_settings` is a callback function which is invoked\n when SETTINGS frame is received."]
    pub recv_settings: nghttp3_recv_settings,
    #[doc = " :member:`recv_origin` is a callback function which is invoked\n when a single origin in an ORIGIN frame is received.  This field\n is available since v1.11.0."]
    pub recv_origin: nghttp3_recv_origin,
    #[doc = " :member:`end_origin` is a callback function which is invoked when\n an ORIGIN frame has been completely processed.  This field is\n available since v1.11.0."]
    pub end_origin: nghttp3_end_origin,
    #[doc = " :member:`rand` is a callback function which is invoked when\n unpredictable data are needed.  Although this field is optional\n due to the backward compatibility, it is recommended to specify\n this field to harden the runtime behavior against suspicious\n activities of a remote endpoint.  This field is available since\n v1.11.0."]
    pub rand: nghttp3_rand,
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_settings_default` fills |settings| with the default\n values.\n\n - :member:`max_field_section_size\n   <nghttp3_settings.max_field_section_size>` = :expr:`((1ull << 62) - 1)`\n - :member:`qpack_max_dtable_capacity\n   <nghttp3_settings.qpack_max_dtable_capacity>` = 0\n - :member:`qpack_encoder_max_dtable_capacity\n   <nghttp3_settings.qpack_encoder_max_dtable_capacity>` = 4096\n - :member:`qpack_blocked_streams\n   <nghttp3_settings.qpack_blocked_streams>` = 0\n - :member:`enable_connect_protocol\n   <nghttp3_settings.enable_connect_protocol>` = 0"]
    pub fn nghttp3_settings_default_versioned(
        settings_version: ::std::os::raw::c_int,
        settings: *mut nghttp3_settings,
    );
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_client_new` creates :type:`nghttp3_conn`, and\n initializes it for client use.  The pointer to the object is stored\n in |*pconn|.  If |mem| is ``NULL``, the memory allocator returned\n by `nghttp3_mem_default` is used.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_client_new_versioned(
        pconn: *mut *mut nghttp3_conn,
        callbacks_version: ::std::os::raw::c_int,
        callbacks: *const nghttp3_callbacks,
        settings_version: ::std::os::raw::c_int,
        settings: *const nghttp3_settings,
        mem: *const nghttp3_mem,
        conn_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_server_new` creates :type:`nghttp3_conn`, and\n initializes it for server use.  The pointer to the object is stored\n in |*pconn|.  If |mem| is ``NULL``, the memory allocator returned\n by `nghttp3_mem_default` is used.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_server_new_versioned(
        pconn: *mut *mut nghttp3_conn,
        callbacks_version: ::std::os::raw::c_int,
        callbacks: *const nghttp3_callbacks,
        settings_version: ::std::os::raw::c_int,
        settings: *const nghttp3_settings,
        mem: *const nghttp3_mem,
        conn_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_del` frees resources allocated for |conn|.  This\n function also frees memory pointed by |conn| itself.  This function\n does nothing if |conn| is NULL."]
    pub fn nghttp3_conn_del(conn: *mut nghttp3_conn);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_bind_control_stream` binds stream denoted by\n |stream_id| to outgoing unidirectional control stream.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_INVALID_STATE`\n     Control stream has already corresponding stream ID.\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_bind_control_stream(
        conn: *mut nghttp3_conn,
        stream_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_bind_qpack_streams` binds stream denoted by\n |qenc_stream_id| to outgoing QPACK encoder stream, and stream\n denoted by |qdec_stream_id| to outgoing QPACK encoder stream.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_INVALID_STATE`\n     QPACK encoder/decoder stream have already corresponding stream\n     IDs.\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_bind_qpack_streams(
        conn: *mut nghttp3_conn,
        qenc_stream_id: i64,
        qdec_stream_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_read_stream` reads data |src| of length |srclen| on\n stream identified by |stream_id|.  It returns the number of bytes\n consumed.  The \"consumed\" means that application can increase flow\n control credit (both stream and connection) of underlying QUIC\n connection by that amount.  It does not include the amount of data\n carried by DATA frame which contains application data (excluding\n any control or QPACK unidirectional streams).  See\n :type:`nghttp3_recv_data` to handle those bytes.  If |fin| is\n nonzero, this is the last data from remote endpoint in this stream.\n\n This function returns the number of bytes consumed, or one of the\n following negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory.\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`\n     User callback failed.\n\n It may return the other error codes.  The negative error code means\n that |conn| encountered a connection error, and the connection must\n be closed.  Calling nghttp3 API other than `nghttp3_conn_del`\n causes undefined behavior."]
    pub fn nghttp3_conn_read_stream(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        src: *const u8,
        srclen: usize,
        fin: ::std::os::raw::c_int,
    ) -> nghttp3_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_writev_stream` stores stream data to send to |vec| of\n length |veccnt|, and returns the number of nghttp3_vec object in\n which it stored data.  It stores stream ID to |*pstream_id|.  An\n application has to call `nghttp3_conn_add_write_offset` to inform\n |conn| of the actual number of bytes that underlying QUIC stack\n accepted.  |*pfin| will be nonzero if this is the last data to\n send.  If there is no stream to write data or send fin, this\n function returns 0, and -1 is assigned to |*pstream_id|.  This\n function may return 0, and |*pstream_id| is not -1, and |*pfin| is\n nonzero.  It means 0 length data to |*pstream_id|, and it is the\n last data to the stream.  They must be passed to QUIC stack, and\n they are accepted, the application has to call\n `nghttp3_conn_add_write_offset` with 0 byte.\n\n This function returns the number of bytes consumed, or one of the\n following negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory.\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`\n     User callback failed.\n\n It may return the other error codes.  The negative error code means\n that |conn| encountered a connection error, and the connection must\n be closed.  Calling nghttp3 API other than `nghttp3_conn_del`\n causes undefined behavior."]
    pub fn nghttp3_conn_writev_stream(
        conn: *mut nghttp3_conn,
        pstream_id: *mut i64,
        pfin: *mut ::std::os::raw::c_int,
        vec: *mut nghttp3_vec,
        veccnt: usize,
    ) -> nghttp3_ssize;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_add_write_offset` tells |conn| the number of bytes\n |n| for stream denoted by |stream_id| QUIC stack accepted.\n\n If stream has no data to send but just sends fin (closing the write\n side of a stream), the number of bytes sent is 0.  It is important\n to call this function even if |n| is 0 in this case.  It is safe to\n call this function if |n| is 0.\n\n `nghttp3_conn_writev_stream` must be called before calling this\n function to get data to send, and those data must be fed into QUIC\n stack.\n\n If a stream denoted by |stream_id| is not found, this function\n returns 0.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_add_write_offset(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_add_ack_offset` tells |conn| the number of bytes |n|\n for stream denoted by |stream_id| QUIC stack has acknowledged.\n\n If a stream denoted by |stream_id| is not found, this function\n returns 0.\n\n Alternatively, `nghttp3_conn_update_ack_offset` can be used to\n accomplish the same thing.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`\n     User callback failed."]
    pub fn nghttp3_conn_add_ack_offset(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        n: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_update_ack_offset` tells |conn| that QUIC stack has\n acknowledged the stream data up to |offset| for a stream denoted by\n |stream_id|.\n\n If a stream denoted by |stream_id| is not found, this function\n returns 0.\n\n Alternatively, `nghttp3_conn_add_ack_offset` can be used to\n accomplish the same thing.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_INVALID_ARGUMENT`\n     |offset| is less than the number of bytes acknowledged so far.\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`\n     User callback failed."]
    pub fn nghttp3_conn_update_ack_offset(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        offset: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_block_stream` tells the library that stream\n identified by |stream_id| is blocked due to QUIC flow control."]
    pub fn nghttp3_conn_block_stream(conn: *mut nghttp3_conn, stream_id: i64);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_unblock_stream` tells the library that stream\n identified by |stream_id| which was blocked by QUIC flow control\n (see `nghttp3_conn_block_stream`) is unblocked.\n\n If a stream denoted by |stream_id| is not found, this function\n returns 0.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_unblock_stream(
        conn: *mut nghttp3_conn,
        stream_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_is_stream_writable` returns nonzero if a stream\n identified by |stream_id| is writable.  It is not writable if:\n\n - the stream does not exist; or,\n - the stream is closed (e.g., `nghttp3_conn_close_stream` is\n   called); or,\n - the stream is QUIC flow control blocked (e.g.,\n   `nghttp3_conn_block_stream` is called); or,\n - the stream is input data blocked (e.g.,\n   :macro:`NGHTTP3_ERR_WOULDBLOCK` is returned from\n   :type:`nghttp3_read_data_callback`); or,\n - the stream is half-closed local (e.g.,\n   `nghttp3_conn_shutdown_stream_write` is called)."]
    pub fn nghttp3_conn_is_stream_writable(
        conn: *mut nghttp3_conn,
        stream_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_shutdown_stream_write` tells the library that any\n further write operation to stream identified by |stream_id| is\n prohibited.  This works like `nghttp3_conn_block_stream`, but it\n cannot be unblocked by `nghttp3_conn_unblock_stream`."]
    pub fn nghttp3_conn_shutdown_stream_write(conn: *mut nghttp3_conn, stream_id: i64);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_shutdown_stream_read` tells the library that\n read-side of stream denoted by |stream_id| is abruptly closed, and\n any further incoming data and pending stream data should be\n discarded.\n\n If a stream denoted by |stream_id| is not client bidirectional\n stream, this function returns 0.  If the stream has already\n shutdown read-side stream, this function returns 0.\n\n This function does not fail if a stream denoted by |stream_id| is\n not found, although it may fail with the other reasons.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory.\n :macro:`NGHTTP3_ERR_QPACK_FATAL`\n     QPACK decoder stream overflow."]
    pub fn nghttp3_conn_shutdown_stream_read(
        conn: *mut nghttp3_conn,
        stream_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_resume_stream` resumes stream identified by\n |stream_id| which was previously unable to provide data.  See\n :type:`nghttp3_read_data_callback`.\n\n If a stream denoted by |stream_id| is not found, this function\n returns 0.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_resume_stream(
        conn: *mut nghttp3_conn,
        stream_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_close_stream` tells the library that a stream\n identified by |stream_id| has been closed.  QUIC application error\n code |app_error_code| is the reason of the closure.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_STREAM_NOT_FOUND`\n     Stream not found.\n :macro:`NGHTTP3_ERR_H3_CLOSED_CRITICAL_STREAM`\n     A critical stream is closed.\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`\n     User callback failed"]
    pub fn nghttp3_conn_close_stream(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        app_error_code: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_set_max_client_streams_bidi` tells |conn| the\n cumulative number of bidirectional streams that client can open."]
    pub fn nghttp3_conn_set_max_client_streams_bidi(conn: *mut nghttp3_conn, max_streams: u64);
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_set_max_concurrent_streams` tells |conn| the maximum\n number of concurrent streams that a remote endpoint can open,\n including both bidirectional and unidirectional streams which\n potentially receive QPACK encoded HEADERS frame.  This value is\n used as a hint to limit the internal resource consumption."]
    pub fn nghttp3_conn_set_max_concurrent_streams(
        conn: *mut nghttp3_conn,
        max_concurrent_streams: usize,
    );
}
#[doc = " @functypedef\n\n :type:`nghttp3_read_data_callback` is a callback function invoked\n when the library asks an application to provide stream data for a\n stream denoted by |stream_id|.\n\n The library provides |vec| of length |veccnt| to the application.\n The application should fill data and its length to |vec|.  It has\n to return the number of the filled objects.  The application must\n retain data until they are safe to free.  It is notified by\n :type:`nghttp3_acked_stream_data` callback.\n\n If this is the last data to send (or there is no data to send\n because all data have been sent already), set\n :macro:`NGHTTP3_DATA_FLAG_EOF` to |*pflags|.\n\n If the application is unable to provide data temporarily, return\n :macro:`NGHTTP3_ERR_WOULDBLOCK`.  When it is ready to provide data,\n call `nghttp3_conn_resume_stream`.\n\n The callback should return the number of objects in |vec| that the\n application filled if it succeeds, or\n :macro:`NGHTTP3_ERR_CALLBACK_FAILURE`.\n\n TODO Add NGHTTP3_ERR_TEMPORAL_CALLBACK_FAILURE to reset just this\n stream."]
pub type nghttp3_read_data_callback = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        vec: *mut nghttp3_vec,
        veccnt: usize,
        pflags: *mut u32,
        conn_user_data: *mut ::std::os::raw::c_void,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> nghttp3_ssize,
>;
#[doc = " @struct\n\n :type:`nghttp3_data_reader` specifies the way how to generate\n request or response body."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_data_reader {
    #[doc = " :member:`read_data` is a callback function to generate body."]
    pub read_data: nghttp3_read_data_callback,
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_submit_request` submits HTTP request header fields\n and body on the stream identified by |stream_id|.  |stream_id| must\n be a client initiated bidirectional stream.  Only client can submit\n HTTP request.  |nva| of length |nvlen| specifies HTTP request\n header fields.  |dr| specifies a request body.  If there is no\n request body, specify NULL.  If |dr| is NULL, it implies the end of\n stream.  |stream_user_data| is an opaque pointer attached to the\n stream.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_CONN_CLOSING`\n     Connection is shutting down, and no new stream is allowed.\n :macro:`NGHTTP3_ERR_STREAM_IN_USE`\n     Stream has already been opened.\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_submit_request(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        nva: *const nghttp3_nv,
        nvlen: usize,
        dr: *const nghttp3_data_reader,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_submit_info` submits HTTP non-final response header\n fields on the stream identified by |stream_id|.  |nva| of length\n |nvlen| specifies HTTP response header fields.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_STREAM_NOT_FOUND`\n     Stream not found\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_submit_info(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        nva: *const nghttp3_nv,
        nvlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_submit_response` submits HTTP response header fields\n and body on the stream identified by |stream_id|.  |nva| of length\n |nvlen| specifies HTTP response header fields.  |dr| specifies a\n response body.  If there is no response body, specify NULL.  If\n |dr| is NULL, it implies the end of stream.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_STREAM_NOT_FOUND`\n     Stream not found\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_submit_response(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        nva: *const nghttp3_nv,
        nvlen: usize,
        dr: *const nghttp3_data_reader,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_submit_trailers` submits HTTP trailer fields on the\n stream identified by |stream_id|.  |nva| of length |nvlen|\n specifies HTTP trailer fields.  Calling this function implies the\n end of stream.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_STREAM_NOT_FOUND`\n     Stream not found\n :macro:`NGHTTP3_ERR_INVALID_STATE`\n     Application has already submitted fin to stream.\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_submit_trailers(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        nva: *const nghttp3_nv,
        nvlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_submit_shutdown_notice` notifies the other endpoint\n to stop creating new stream.  After a couple of RTTs later, call\n `nghttp3_conn_shutdown` to start graceful shutdown.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_submit_shutdown_notice(conn: *mut nghttp3_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_shutdown` starts graceful shutdown.  It should be\n called after `nghttp3_conn_submit_shutdown_notice` and a couple of\n RTTs.  After calling this function, the local endpoint starts\n rejecting new incoming streams.  The existing streams are processed\n normally.  See also `nghttp3_conn_is_drained`.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_shutdown(conn: *mut nghttp3_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_set_stream_user_data` sets |stream_user_data| to the\n stream identified by |stream_id|.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_STREAM_NOT_FOUND`\n     Stream not found."]
    pub fn nghttp3_conn_set_stream_user_data(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        stream_user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_get_frame_payload_left` returns the number of bytes\n left to read current frame payload for a stream denoted by\n |stream_id|.  If no such stream is found, or |stream_id| identifies\n neither client bidirectional stream nor remote control stream, it\n returns 0."]
    pub fn nghttp3_conn_get_frame_payload_left(conn: *mut nghttp3_conn, stream_id: i64) -> u64;
}
#[doc = " @struct\n\n :type:`nghttp3_pri` represents HTTP priority."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_pri {
    #[doc = " :member:`urgency` is the urgency of a stream, it must be in\n [:macro:`NGHTTP3_URGENCY_HIGH`, :macro:`NGHTTP3_URGENCY_LOW`],\n inclusive, and 0 is the highest urgency."]
    pub urgency: u32,
    #[doc = " :member:`inc` indicates that a content can be processed\n incrementally or not.  If it is 0, it cannot be processed\n incrementally.  If it is 1, it can be processed incrementally.\n Other value is not permitted."]
    pub inc: u8,
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_get_stream_priority` stores stream priority of a\n stream denoted by |stream_id| into |*dest|.  |stream_id| must\n identify client initiated bidirectional stream.  Only server can\n use this function.\n\n This function must not be called if |conn| is initialized as\n client.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_INVALID_ARGUMENT`\n     |stream_id| is not a client initiated bidirectional stream ID.\n :macro:`NGHTTP3_ERR_STREAM_NOT_FOUND`\n     Stream not found."]
    pub fn nghttp3_conn_get_stream_priority_versioned(
        conn: *mut nghttp3_conn,
        pri_version: ::std::os::raw::c_int,
        dest: *mut nghttp3_pri,
        stream_id: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_set_client_stream_priority` updates priority of a\n stream denoted by |stream_id| with the value pointed by |data| of\n length |datalen|, which should be a serialized :rfc:`9218` priority\n field value.  |stream_id| must identify client initiated\n bidirectional stream.\n\n This function must not be called if |conn| is initialized as\n server.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_INVALID_ARGUMENT`\n     |stream_id| is not a client initiated bidirectional stream ID.\n :macro:`NGHTTP3_ERR_STREAM_NOT_FOUND`\n     Stream not found.\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_set_client_stream_priority(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        data: *const u8,
        datalen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_set_server_stream_priority` updates priority of a\n stream denoted by |stream_id| with the value pointed by |pri|.\n |stream_id| must identify client initiated bidirectional stream.\n\n This function must not be called if |conn| is initialized as\n client.\n\n This function completely overrides stream priority set by client,\n and any attempts to update priority by client are ignored.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_INVALID_ARGUMENT`\n     |stream_id| is not a client initiated bidirectional stream ID.\n :macro:`NGHTTP3_ERR_STREAM_NOT_FOUND`\n     Stream not found.\n :macro:`NGHTTP3_ERR_NOMEM`\n     Out of memory."]
    pub fn nghttp3_conn_set_server_stream_priority_versioned(
        conn: *mut nghttp3_conn,
        stream_id: i64,
        pri_version: ::std::os::raw::c_int,
        pri: *const nghttp3_pri,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_vec_len` returns the sum of length in |vec| of |cnt|\n elements."]
    pub fn nghttp3_vec_len(vec: *const nghttp3_vec, cnt: usize) -> u64;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_check_header_name` returns nonzero if HTTP field name\n |name| of length |len| is valid according to\n :rfc:`7230#section-3.2`.\n\n Because this is an HTTP field name in HTTP/3, the upper cased\n alphabet is treated as error."]
    pub fn nghttp3_check_header_name(name: *const u8, len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_check_header_value` returns nonzero if HTTP field value\n |value| of length |len| is valid according to\n :rfc:`7230#section-3.2`."]
    pub fn nghttp3_check_header_value(value: *const u8, len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_conn_is_drained` returns nonzero if\n `nghttp3_conn_shutdown` has been called, and there is no active\n remote streams.  This function is for server use only."]
    pub fn nghttp3_conn_is_drained(conn: *mut nghttp3_conn) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_pri_parse_priority` parses Priority header field value\n pointed by |value| of length |len|, and stores the result in the\n object pointed by |dest|.  Priority header field is defined in\n :rfc:`9218`.\n\n This function does not initialize the object pointed by |dest|\n before storing the result.  It only assigns the values that the\n parser correctly extracted to fields.\n\n This function returns 0 if it succeeds, or one of the following\n negative error codes:\n\n :macro:`NGHTTP3_ERR_INVALID_ARGUMENT`\n     Failed to parse the header field value."]
    pub fn nghttp3_pri_parse_priority_versioned(
        pri_version: ::std::os::raw::c_int,
        dest: *mut nghttp3_pri,
        value: *const u8,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @struct\n\n :type:`nghttp3_info` is what `nghttp3_version` returns.  It holds\n information about the particular nghttp3 version."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nghttp3_info {
    #[doc = " :member:`age` is the age of this struct.  This instance of\n nghttp3 sets it to :macro:`NGHTTP3_VERSION_AGE` but a future\n version may bump it and add more struct fields at the bottom"]
    pub age: ::std::os::raw::c_int,
    #[doc = " :member:`version_num` is the :macro:`NGHTTP3_VERSION_NUM` number\n (since age == 1)"]
    pub version_num: ::std::os::raw::c_int,
    #[doc = " :member:`version_str` points to the :macro:`NGHTTP3_VERSION`\n string (since age ==1)"]
    pub version_str: *const ::std::os::raw::c_char,
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_version` returns a pointer to a :type:`nghttp3_info`\n struct with version information about the run-time library in use.\n The |least_version| argument can be set to a 24 bit numerical value\n for the least accepted version number, and if the condition is not\n met, this function will return a ``NULL``.  Pass in 0 to skip the\n version checking."]
    pub fn nghttp3_version(least_version: ::std::os::raw::c_int) -> *const nghttp3_info;
}
unsafe extern "C" {
    #[doc = " @function\n\n `nghttp3_err_is_fatal` returns nonzero if |liberr| is a fatal\n error.  |liberr| must be one of nghttp3 library error codes (which\n is defined as NGHTTP3_ERR_* macro, such as\n :macro:`NGHTTP3_ERR_NOMEM`)."]
    pub fn nghttp3_err_is_fatal(liberr: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}